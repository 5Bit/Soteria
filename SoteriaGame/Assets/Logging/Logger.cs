//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

/*
 * Logger (Singleton)
 * 
 * Logger singleton is persistent; it will live through scene transitions
 * and won't be destroyed until the application closes.
 * 
 * Logging has 3 levels: Verbose(Default), Warning, Error
 * 
 * Logging a warning/error won't throw any exceptions, it just changes
 * the format of the log message (for example, error messages logged to the Unity console
 * will have red text).
 * 
 * In order to log a message you must first register a log channel with a log level
 * of your choice.  Log channels are unique by their names so no 2 log channels may 
 * have the same name. Trying to create a duplicate log channel will output an error 
 * to the Unity console.  You may specify whether that channels logs to a the Unity console
 * or a file on disk which will take name: "LogChannelName_LogCreationDate_LogCreationTime.log"
 * 
 * Users can log messages using Log, LogWarning, and LogError public functions.
 * If you wish for your log message to be stamped with a timestamp, pass true to the timestamp param
 * for these functions
 * 
 * As of now logging will take place for all builds.  Still working on automatically removing
 * log calls during release builds
 * 
 * Might add more if needed
 * 
 * NOTE: Creating a log channel with its own log file
 * will create a directoy named "Logs" at the solution directory
 * level with your file in it.  Just a heads up if you want to delete your
 * log directory before a check in.
 */

public sealed class Logger : Singleton<Logger>
{
	public enum LogLevel
	{
		E_LOG_WARN,
		E_LOG_ERROR,
		E_LOG_VERBOSE,

	}


	private Dictionary<string, LogLevel> m_ChannelMap;
	private Dictionary<string, StreamWriter> m_LogFileMap;
	
	private void Awake()
	{
		m_ChannelMap = new Dictionary<string, LogLevel> ();
		m_LogFileMap = new Dictionary<string, StreamWriter> ();

		Directory.CreateDirectory ("Logs");
	}

	private string PrivGetTimestampString()
	{
		//get the time
		DateTime now = DateTime.Now;

		StringBuilder builder = new StringBuilder ();

		//build the formatted string
		builder.Append ("Logged At: ");
		builder.Append (now.ToShortTimeString());
		builder.Append ("\n");

		//spit it out
		return builder.ToString();
	}


	private string GetLogFileName(string channel)
	{
		DateTime now = DateTime.Now;


		//build out the filename
		StringBuilder builder = new StringBuilder ();

		builder.Append ("Logs\\");
		builder.Append (channel);
		builder.Append ("_");
		builder.Append (now.ToString ("MMddyyy"));
		builder.Append ("_");
		builder.Append (now.ToString("HH_mm"));
		builder.Append (".log");

		//spit it out
		return builder.ToString ();
	}

	private void PrivLogMsg(string channel, string msg, LogLevel level, bool timestamp)
	{
		//get a ref
		Dictionary<string, LogLevel> channels = Instance.m_ChannelMap;

		//we'll only log if the channel requested exists
		//and if the channels log level is greater or equal to the request logging level

		bool containsKey = channels.ContainsKey (channel);

		if (containsKey && channels[channel] >= level)
		{
			Dictionary<string, StreamWriter> files = Instance.m_LogFileMap;

			//if timestamp requested, get one
			string logMsg = channel + "<" + level.ToString() + ">: " + msg;
			string logMsgFinal = timestamp == true ? (this.PrivGetTimestampString() + logMsg) : logMsg;

			//did user register this channel as a log file?
			bool isFile = files.ContainsKey(channel);

			//write to the file
			if(isFile)
			{
				files[channel].WriteLine(logMsgFinal);
			}

			//otherwise write to console
			else
			{
				switch(level)
				{
				case LogLevel.E_LOG_WARN :
					Debug.LogWarning(logMsgFinal);
					break;
				case LogLevel.E_LOG_ERROR :
					Debug.LogError(logMsgFinal);
					break;
				case LogLevel.E_LOG_VERBOSE :
					Debug.Log(logMsgFinal);
					break;
				}
			}
		}

		else if(!containsKey)
		{
			Debug.LogError("Logger <Missing Channel>: " + channel + " doesn't not exist! Message not logged!\n");
		}
	}


	/*
	 * void RegisterNewChannel
	 * 
	 * Creates a new channel to log to.
	 * 
	 * string 'channel': Name of new log channel to register.  New channel
	 * will not be created if name is already in use
	 * 
	 * LogLevel 'logLevel': Logging level (Verbose, Warning, Error)
	 * Log levels Warning/Error will output text to console with different colors
	 * 
	 * bool 'createLogFile': Specify whether or not you wish to create a log file
	 * on disk to write your messages to for this channel.  If false, messages will output
	 * to console.
	 */

	//[System.Diagnostics.Conditional("DEBUG")]
	public static void RegisterNewChannel(string channel, LogLevel logLevel, bool createLogFile)
	{
		Dictionary<string, LogLevel> channels = Instance.m_ChannelMap;

		bool containsKey = channels.ContainsKey (channel);

		if(containsKey)
		{
			Debug.LogWarning("Channel <" + channel + "> not created, already exists!!\n");
		}

		else
		{
			channels[channel] = logLevel;
		}

		if(!containsKey && createLogFile)
		{
			Dictionary<string, StreamWriter> files = Instance.m_LogFileMap;

			string logFileName = Instance.GetLogFileName(channel);

			files[channel] = new StreamWriter(logFileName, true);
		}
	}


	/*
	 * void Log
	 * 
	 * Logs a basic message to specified channel
	 * 
	 * string 'channel': Name of new log channel to register.  New channel
	 * will not be created if name is already in use
	 * 
	 * string 'msg': Message to be logged
	 * 
	 * bool 'timestamp': Specify whether or not you wish for your log message
	 * to have a timestamp
	 */

	//[System.Diagnostics.Conditional("DEBUG")]
	public static void Log(string channel, string msg, bool timestamp)
	{
		Instance.PrivLogMsg (channel, msg, LogLevel.E_LOG_VERBOSE, timestamp);
	}


	/*
	 * void LogWarning
	 * 
	 * Logs a warning message to specified channel
	 * 
	 * string 'channel': Name of new log channel to register.  New channel
	 * will not be created if name is already in use
	 * 
	 * string 'msg': Message to be logged
	 * 
	 * bool 'timestamp': Specify whether or not you wish for your log message
	 * to have a timestamp
	 */
	//[System.Diagnostics.Conditional("DEBUG")]
	public static void LogWarning(string channel, string msg, bool timestamp)
	{
		Instance.PrivLogMsg (channel, msg, LogLevel.E_LOG_WARN, timestamp);
	}


	/*
	 * void LogError
	 * 
	 * Logs an error message to specified channel
	 * 
	 * string 'channel': Name of new log channel to register.  New channel
	 * will not be created if name is already in use
	 * 
	 * string 'msg': Message to be logged
	 * 
	 * bool 'timestamp': Specify whether or not you wish for your log message
	 * to have a timestamp
	 */
	//[System.Diagnostics.Conditional("DEBUG")]
	public static void LogError(string channel, string msg, bool timestamp)
	{
		Instance.PrivLogMsg (channel, msg, LogLevel.E_LOG_ERROR, timestamp);
	}



	protected override void VOnDestroy()
	{
		Dictionary<string, StreamWriter> files = Instance.m_LogFileMap;

		if(files.Count > 0)
		{
			foreach(KeyValuePair<string, StreamWriter> file in files)
			{
				//empty out the buffer
				file.Value.Flush();
				//give back to OS
				file.Value.Dispose();
			}

			//trash it
			files.Clear();
		}
	}
}

